      else { el.style.transform='translate(0,0) rotate(0)'; el.style.opacity='1'; }
      dragging=false; currentX=0;
    };
    el.addEventListener('pointerdown', e=>{ if(e.button===0){el.setPointerCapture(e.pointerId); onStart(e.clientX,e.clientY);} });
    el.addEventListener('pointermove', e=>onMove(e.clientX,e.clientY));
    el.addEventListener('pointerup', onEnd);
    el.addEventListener('pointercancel', onEnd);
  }

  // ---- Actions ----
  function actSave(){
    if(idx >= items.length) return;
    const item = items[idx];
    saved.push(item);
    historyStack.push({item, action:'save'});
    idx++;
    renderNext();
  }
  function actPass(){
    if(idx >= items.length) return;
    const item = items[idx];
    historyStack.push({item, action:'pass'});
    idx++;
    renderNext();
  }
  function actUndo(){
    const last = historyStack.pop();
    if(!last) return;
    idx = Math.max(0, idx-1);
    if(last.action==='save'){ // remove last occurrence
      const i = saved.findIndex(x=>x.date===last.item.date && x.url===last.item.url);
      if(i>-1) saved.splice(i,1);
    }
    renderNext();
  }

  // ---- Data loading ----
  document.getElementById('load').addEventListener('click', loadYear);
  document.getElementById('saveBtn').addEventListener('click', actSave);
  document.getElementById('passBtn').addEventListener('click', actPass);
  document.getElementById('zipBtn').addEventListener('click', downloadZip);
  document.getElementById('year').value = new Date().getFullYear();

  document.addEventListener('keydown', e=>{
    if(e.key==='ArrowRight') actSave();
    else if(e.key==='ArrowLeft') actPass();
    else if(e.key.toLowerCase()==='z') actUndo();
    else if(e.key.toLowerCase()==='d') downloadZip();
  });

  async function loadYear(){
    const y = Number(document.getElementById('year').value);
    if(!y || y<2009 || y>2099){ toast('Enter valid year'); return; }
    toast('Loading…');
    items = []; idx=0; saved=[]; historyStack=[]; updateHUD(); stage.innerHTML='';
    // Strategy:
    // 1) Try master list: API_BASE?year=YYYY → expect array of entries
    // 2) If not, iterate dates Jan 1..Dec 31 → API_BASE?date=YYYY-MM-DD
    // 3) Normalize to {date,title,copyright,url}
    let list = await tryFetchList(y);
    if(!list || !list.length){
      list = await fetchDailyFallback(y);
    }
    items = normalizeList(list, y).filter(x=>!!x.url);
    // De-dup, sort by date
    const seen = new Set();
    items = items.filter(it=>{ const k=it.date+'|'+it.url; if(seen.has(k)) return false; seen.add(k); return true; })
                 .sort((a,b)=> a.date.localeCompare(b.date));
    if(!items.length){ toast('No images found for year'); updateHUD(); return; }
    toast(`Loaded ${items.length}`);
    renderNext();
  }

  async function tryFetchList(year){
    try{
      // Attempt 1: ?year=YYYY
      const r1 = await fetch(`${API_BASE}?year=${year}`, {mode:'cors'});
      if(r1.ok){ const j = await r1.json(); if(Array.isArray(j) || j.images) return j; }
    }catch{}
    try{
      // Attempt 2: /YYYY.json (some mirrors expose this)
      const u = new URL(API_BASE);
      const base = u.origin + u.pathname.replace(/\/[^\/]*$/,''); // strip filename
      const r2 = await fetch(`${base}/${year}.json`, {mode:'cors'});
      if(r2.ok){ const j = await r2.json(); if(Array.isArray(j) || j.images) return j; }
    }catch{}
    return null;
  }

  async function fetchDailyFallback(year){
    const results = [];
    const start = new Date(Date.UTC(year,0,1));
    const end = new Date(Date.UTC(year,11,31));
    const urls = [];
    // Try ?date=YYYY-MM-DD pattern
    for(let d=new Date(start); d<=end; d.setUTCDate(d.getUTCDate()+1)){
      const iso = d.toISOString().slice(0,10);
      urls.push(`${API_BASE}?date=${iso}`);
    }
    // Fetch with limited concurrency
    let i = 0;
    async function worker(){
      while(i<urls.length){
        const my = i++;
        try{
          const r = await fetch(urls[my], {mode:'cors'});
          if(r.ok){
            const j = await r.json();
            if(j) results.push(j);
          }
        }catch{}
      }
    }
    const workers = Array.from({length:8}, worker);
    await Promise.all(workers);
    return results;
  }

  function normalizeList(raw, year){
    // Accept shapes:
    // A) { images:[{startdate, enddate, url, urlbase, copyright, title}] }
    // B) Array of A or of image objects
    // C) Single object with those fields
    const bucket = [];
    const pushFromImage = (im) => {
      if(!im) return;
      // date
      const d = im.fullstartdate || im.startdate || im.date || '';
      const dateStr = normalizeDate(d, year);
      // url candidates
      let url = null;
      if(im.url && /^https?:/.test(im.url)) url = im.url;
      else if(im.hd || im.uhd) url = im.hd || im.uhd;
      else if(im.url) url = 'https://www.bing.com' + im.url;
      else if(im.urlbase){
        url = `https://www.bing.com${im.urlbase}_UHD.jpg`;
      }
      // some mirrors expose direct JPG at predictable paths:
      if(!url && dateStr){
        try{
          // https://bing.npanuhin.me/US/en/YYYY/MM/DD.jpg or YYYY-MM-DD.jpg variants
          url = `https://bing.npanuhin.me/US/en/${dateStr}.jpg`;
        }catch{}
      }
      bucket.push({
        date: dateStr || `${year}`,
        title: im.title || im.caption || '',
        copyright: im.copyright || '',
        url
      });
    };
    const pushFromBlock = (blk) => {
      if(!blk) return;
      if(Array.isArray(blk.images)) blk.images.forEach(pushFromImage);
      else if(Array.isArray(blk)) blk.forEach(x=>{ if(x.images) x.images.forEach(pushFromImage); else pushFromImage(x); });
      else if(blk.images) blk.images.forEach(pushFromImage);
      else pushFromImage(blk);
    };
    pushFromBlock(raw);
    return bucket;
  }

  function normalizeDate(s, fallbackYear){
    if(!s) return null;
    // Handles: YYYYMMDD, YYYY-MM-DD, 20240101T0000, etc.
    const m = String(s).match(/^(\d{4})[-/]?(\d{2})[-/]?(\d{2})/);
    if(m) return `${m[1]}-${m[2]}-${m[3]}`;
    // if only day-of-year or missing, fallback
    return `${fallbackYear}`;
  }

  // ---- ZIP download ----
  async function downloadZip(){
    if(!saved.length){ toast('No saved images'); return; }
    toast('Preparing ZIP…');
    const zip = new JSZip();
    const queue = saved.map((it, i)=>({it, i}));

    let active = 0, done = 0, p = Promise.resolve();
    function next(){
      if(!queue.length) return Promise.resolve();
      while(active < MAX_PARALLEL_FETCH && queue.length){
        const {it, i} = queue.shift();
        active++;
        p = p.then(()=> fetchImageToZip(it, zip)
          .catch(()=>{}) // skip failures
          .then(()=>{ active--; done++; progressEl.textContent = `Zipping ${done}/${saved.length}`; return next(); })
        );
      }
      return p;
    }
    await next();
    const content = await zip.generateAsync({type:'blob'});
    const y = document.getElementById('year').value || 'year';
    saveAs(content, `bing-${y}-selected.zip`);
    updateHUD();
    toast('ZIP ready');
  }

  async function fetchImageToZip(it, zip){
    const url = it.url;
    if(!url) return;
    const resp = await fetch(url, {mode:'cors', cache:'force-cache'});
    if(!resp.ok) return;
    const blob = await resp.blob();
    const name = safeName(`${it.date || 'img'}-${(it.title||'').slice(0,64) || 'bing'}.jpg`);
    zip.file(name, blob);
  }

  function safeName(s){
    return s.replace(/[^\w\-\. ]+/g,'_').replace(/\s+/g,' ').trim();
  }

  // First paint
  updateHUD();
  </script>
</body>
</html>
